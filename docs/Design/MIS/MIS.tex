\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

% jen things
\usepackage{amssymb}
\usepackage{listings}

% end jen things

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Kaplan}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{Jen Garner}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 20, 2018 (Tuesday) & 1.0 & Initial draft \\
November 26, 2018 (Monday) & 1.1 & Complete first draft \\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{SRS}{https://github.com/PeaWagon/Kaplan/blob/master/docs/SRS/SRS.pdf} 
Documentation.

cid = compound identification number (for 
\href{pubchem}{https://pubchem.ncbi.nlm.nih.gov/} website)

vetee = private database repository on github

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for 
\progname{}. This program is designed to search a potential energy space for a 
set of conformers for a given input molecule. The energy and RMSD are used to 
optimize dihedral angles, which can then be combined with an original geometry 
specification to determine an overall structure for a conformational isomer.

Complementary documents include the System Requirement Specifications (SRS)
and Module Guide (MG).  The full documentation and implementation can be
found at \url{https://github.com/PeaWagon/Kaplan}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$. Also, the 
PEP8 style guide from Python will be used for naming conventions.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & bool & True or False \\


\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname{} uses some derived data types: sequences, 
strings, tuples, lists, and dictionaries. Sequences are lists filled with 
elements of the same data type. Strings
are sequences of characters. Tuples contain a fixed list of values, potentially 
of different types. Lists are similar to tuples, except that they can change in 
size and their entries can be modified. For strings, lists, and tuples, the 
index can be used to retrieve a value at a certain location. Indexing starts at 
0 and continues until the length of the item minus one (example: for a list 
my\_list = [1,2,3], my\_list[1] returns 2). A slice of these data types affords 
a subsection of the original data (example: given a string s = ``kaplan'', 
s[2:4] gives ``pl''). Notice that the slice's second value is a non-inclusive 
bound. A dictionary is a dynamic set of key-value pairs, where the keys and the 
values can be modified and of any type. A dictionary value is accessed by 
calling its key, as in dictionary\_name[key\_name] = value.

\progname{} uses three special objects called Pmem, Ring, and Parser. These 
objects have methods that are described in \ref{section-pmem}, 
\ref{section-ring}, and \ref{section-geometry} respectively. The Python 
NoneType type object is also used.

Here is a table to summarize the derived data types:

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
population member & Pmem & an object used by \progname{} to represent potential 
solutions to the conformer search/optimization problem \\
ring & Ring & an object used by \progname{} to store Pmem objects and define 
how they are removed, added, and updated \\
parser & Parser & a Vetee object used by \progname{} to represent the molecular 
geometry, its energy calculations, and input/output parameters; also inherited 
classes include: Xyz, Com, Glog, Structure \\
string & str & a string is a list of characters (as implemented in Python) \\
list & list or [ ] & a Python list (doubly-linked) \\
dictionary & dict or \{\} & a Python dictionary that has key value pairs \\
NoneType & None & empty data type \\
\bottomrule
\end{tabular} 
\end{center}

In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification. There 
is one generator function in this program, which uses the yield keyword instead 
of the return keyword. Every time a generator is called, it returns the next 
value in what is usually a for loop.

Note that obvious errors (such as missing inputs) that are handled by the 
Python interpreter are not listed under the exceptions in any of the 
\progname{} modules.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & ~ \\
		\midrule
		
		\multirow{9}{0.3\textwidth}{Behaviour-Hiding Module}& GA Input \\
		& Molecule Input \\
		& GA Control\\
		& $Fit_G$ \\
		& Tournament \\
		& Crossover \& Mutation \\
		& Ring \\
		& Pmem \\
		& Output \\
		
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision Module} & Geometry \\
		& Energies \\
		& RMSD \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of GA Input} \label{section-ga_input}

\meow{Right now the link does not open the SRS document. Not sure if that was 
supposed to happen.}

The purpose of this module is to provide a utility for reading and verifying 
input related to the genetic algorithm (GA). There are two main functions: 
read\_ga\_input and verify\_ga\_input. The first function opens a data file 
(.txt file) with the following format:

\begin{lstlisting}
num_mevs = 1000
num_slots = 100
num_filled = 20
num_geoms = 3
num_atoms = 10
t_size = 7
num_muts = 3
num_swaps = 1
pmem_dist = 5
fit_form = 0
coef_energy = 0.5
coef_rmsd = 0.5
\end{lstlisting}

These values are read into a Python dictionary, called ga\_input\_dict. The 
order of the inputs does not matter, but \progname{} will throw an error if one 
of the keys is missing. This dictionary is then passed to the second function, 
which checks that the values are correct and that all keys have been given. 
From the SRS document (see SRS Section \ref{SRS-symbols}), $n_G$ and $n_a$ are 
represented here as num\_geoms and num\_atoms respectively. Also, coef\_energy 
and coef\_rmsd are $C_\text{E}$ and $C_\text{RMSD}$ from the SRS. All keys are 
case insensitive.

\meow{I may have to check if SMILES strings are case sensitive for the programs 
I am parsing them with.}

\subsection{Module}

ga\_input

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

NUM\_GA\_ARGS := 12

\subsubsection{Exported Access Programs}

\begin{table}[H]
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{5cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		read\_ga\_input   & str  & dict & FileNotFoundError \\
		verify\_ga\_input & dict & None    & ValueError \\
		\bottomrule
	\end{tabular}
\end{table}
\subsection{Semantics}

\subsubsection{State Variables}

\noindent num\_args := for each line in the ga\_input\_file $+(x : list | key 
\in x \land value \in x \land 
length(x) = 2 : 1)$ \\

\noindent ga\_input\_dict, which is a dictionary that contains:
\begin{itemize}
\item num\_mevs := $\mathbb{N}$
\item num\_geoms := $\mathbb{N}$
\item num\_atoms := $\{x \in \mathbb{N}: x > 3\}$
\item num\_slots := $\{x \in \mathbb{N}: x \geq \text{num\_filled} \}$
\item num\_filled := $\{x \in \mathbb{N}: x \leq \text{num\_slots}\}$
\item num\_muts := $\{0 \lor x \in \mathbb{N}: \text{num\_atoms} \geq x \geq 
0\}$
\item num\_swaps := $\{0 \lor x \in \mathbb{N}: \text{num\_geoms} \geq x \geq 
0\}$
\item t\_size := $\{x \in \mathbb{N}: 2 \geq x \leq \text{num\_filled} \}$
\item pmem\_dist := $\{0 \lor x \in \mathbb{N}: x \geq 0\}$
\item fit\_form := $\{0 \lor x \in \mathbb{N}: x \geq 0\}$
\item coef\_energy: $\mathbb{R}$
\item coef\_rmsd: $\mathbb{R}$
\end{itemize}

\subsubsection{Environment Variables}

ga\_input\_file: str representing the file that exists in the working directory 
(optionally includes a prepended path).

\subsubsection{Assumptions}

This module is responsible for all type checking and no errors will come from 
incorrect passing of variables (except input related to the molecule - covered 
in \ref{section-mol_input}).

\subsubsection{Access Routine Semantics}

\noindent read\_ga\_input(ga\_input\_file):
\begin{itemize}
	\item transition: open ga\_input\_file and read its contents.
	\item output: dictionary (ga\_input\_dict) that contains the values listed 
	in State Variables.
	\item exception: FileNotFoundError := ga\_input\_file $\notin$ current 
	working directory.
\end{itemize}

\noindent verify\_ga\_input(ga\_input\_dict):
\begin{itemize}
	\item transition: None
	\item output: None
	\item exception: ValueError
	\begin{itemize}
		\item 4 \textgreater num\_atoms
		\item num\_filled \textgreater num\_slots
		\item num\_swaps \textgreater num\_geoms
		\item t\_size \textgreater num\_filled $\lor$ t\_size \textless 2
		\item not an integer type (for all except coef\_energy and coef\_rmsd, 
		which should be floats)
		\item missing key/unknown key
		\item too many keys (i.e. repeated keys), where num\_args $\neq$ 
		NUM\_GA\_ARGS 
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of Molecule Input} \label{section-mol_input}

The purpose of this module is to provide a utility for reading and verifying 
input related to the molecule, including its structure and energy calculations. 
There are two main functions: read\_mol\_input and verify\_mol\_input. The 
first function opens a data file (.txt file) with the following format:

\begin{lstlisting}
qcm = hartree-fock
basis = aug-cc-pvtz
struct_input = C=CC=C
struct_type = smiles
prog = psi4
charge = 0
multip = 1
\end{lstlisting}

These values are read into a Python dictionary, called mol\_input\_dict. The 
order of the inputs does not matter, but \progname{} will throw an error if one 
of the keys is missing. This dictionary is then passed to the second function, 
which checks that the values are correct and that all keys have been given. To 
verify the molecular input, Vetee's Parser object is constructed using the 
mol\_input\_dict (geometry module, Section \ref{section-geometry}). The 
mol\_input module calls the energy module (Section \ref{section-energies}) to 
run a calculation on the input molecule. If this calculation converges, then 
the manipulation of the dihedral angles are more likely to afford calculations 
that converge. After this final verification, the Parser object is passed back 
to the gac module, and eventually gets used by the pmem module 
(Section \ref{section-pmem}). From the SRS document (see SRS Section 
\ref{SRS-symbols}), $QCM$ and $BS$ are represented here as qcm and basis 
respectively. All keys and string values are case insensitive.

\subsection{Module}

mol\_input

\subsection{Uses}

geometry (Section \ref{section-geometry}), energy (Section 
\ref{section-energies})

\subsection{Syntax}

\subsubsection{Exported Constants}

NUM\_MOL\_ARGS := 7

\subsubsection{Exported Access Programs}

\begin{table}[H]
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{5cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		read\_mol\_input   & str  & dict & FileNotFoundError \\
		verify\_mol\_input & dict & Parser & ValueError \\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}

\noindent num\_args := for each line in the mol\_input\_file $+(x : list | key 
\in x \land value \in x \land 
length(x) = 2 : 1)$ \\

\noindent mol\_input\_dict, which is a dictionary that contains:
\begin{itemize}
	\item qcm := str $\in$ available methods given prog
	\item basis := str $\in$ available basis sets given prog and molecule
	\item struct\_input := $\{x : str | x = file \lor x = SMILES \lor x = name 
	\lor x = cid : x\}$
	\item struct\_type := $str \in \{``smiles", ``xyz", ``com", ``glog", 
	``name", ``cid"\} $
	\item prog := $str \in \{``psi4"\}$
	\item charge := $\mathbb{Z}$
	\item multip := $\mathbb{N}$
\end{itemize}

\subsubsection{Environment Variables}

mol\_input\_file: str representing the file that exists in the working 
directory (optionally includes a prepended path).

\subsubsection{Assumptions}

As with \ref{section-ga_input}, other modules that use and exchange the state 
variables found in this module will not raise errors related to the type of 
input.

\subsubsection{Access Routine Semantics}

\noindent read\_mol\_input(mol\_input\_file):
\begin{itemize}
	\item transition: open mol\_input\_file and read its contents.
	\item output: dictionary (mol\_input\_dict) that contains the values listed 
	in State Variables.
	\item exception: FileNotFoundError := mol\_input\_file $\notin$ current 
	working directory.
\end{itemize}

\noindent verify\_mol\_input(mol\_input\_dict):
\begin{itemize}
	\item transition: None
	\item output: Parser
	\item exception: ValueError
	\begin{itemize}
		\item qcm $\notin$ prog
		\item basis $\notin$ prog $\lor$ basis unavailable for molecule
		\item unable to parse SMILES string, name, cid, or input file
		\item struct\_type not available
		\item not a string type (for all except charge $\mathbb{Z}$ and multip 
		$\mathbb{N}$)
		\item missing key/unknown key
		\item too many keys (i.e. repeated keys), where num\_args $\neq$ 
		NUM\_MOL\_ARGS
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of GA Control} \label{section-gac} 

This module is responsible for running the GA using the given inputs. The 
general format of the algorithm is as follows:
\begin{enumerate}
	\item Read in and verify ga\_input\_file (\ref{section-ga_input}).
	\item Read in and verify mol\_input\_file (\ref{section-mol_input}). This 
	step includes a check of the initial geometry, QCM, and BS for convergence 
	(\ref{section-energies}), and generating a Parser object 
	(\ref{section-geometry}).
	\item Generate a Ring object (\ref{section-ring}).
	\item Fill the Ring with Pmem objects according to the num\_filled input 
	variable (\ref{section-pmem}).
	\item Iterate over the num\_mevs input variable, and run a tournament on 
	the Ring according to the t\_size variable (\ref{section-tournament}).
	\item Return the output as per the output module specifications 
	(\ref{section-output}).
\end{enumerate}

\subsection{Module}

gac

\subsection{Uses}

ga\_input (Section \ref{section-ga_input}), 
mol\_input (Section \ref{section-mol_input}),
output (Section \ref{section-output}),
ring (Section \ref{section-ring}),
tournament (Section \ref{section-tournament})

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\meow{Not sure if I should list the exceptions raised by imported modules here? 
For example, reading the input may give an error, but this error is not 
explicitly raised by the gac module. Do I still have to list it here?}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		run\_kaplan & str, str & None & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\meow{I don't actually need to store the mol\_input\_dict variable here since 
its information will be completely contained in the Parser object. Mostly I am 
leaving this note here as a reminder to update the Parser object with the prog 
attribute. This update would also mean consolidating the function calls read 
and verify mol input. Not sure if it is a good idea to have these separated in 
gac?}

\begin{itemize}
	\item ga\_input\_dict : dict (see \ref{section-ga_input})
	\item mol\_input\_dict : dict (see \ref{section-mol_input})
	\item parser : Parser (see \ref{section-geometry})
	\item ring : Ring (see \ref{section-ring})
	\item mev : $\{x : \mathbb{Z} | \text{mum\_mevs} > x \geq 0 : x\}$
\end{itemize}


\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

This is the main control unit for the program; the user will write their own 
input files and only need to access this module to complete their task.

\subsubsection{Access Routine Semantics}

\noindent run\_kaplan(ga\_input\_file, mol\_input\_file):
\begin{itemize}
	\item transition: The set of conformers with large negative energy and high 
	RMSD are produced and passed to the 
	output module (\ref{section-output}).
	\item output: None
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

None
\meow{Since the run\_kaplan function is only used by gac, should I put it here 
in local functions? Technically the user will have to import it somewhere to 
use it.}

\section{MIS of $Fit_G$} \label{section-fitg}

The purpose of this module is to calculate the fitness of the Pmem object. In 
ga\_input\_file, the user specifies the fit\_form (the formula number to use 
for calculating fitness), the coefficients for the energy and RMSD terms, the 
method (QCM), and the basis set (BS). These values are used here to assign a 
fitness to a pmem. A change of dihedral angles may make it impossible for an 
energy calculation to converge; in this case the energy will be set to zero, 
but the RMSD value will most likely be high for the set of conformers. The 
contribution of the RMSD value to the fitness should therefore be smaller than 
the energetic component (otherwise the user may end up with multiple 
non-convergent geometries with high RMSD).

\subsection{Module}

fitg

\subsection{Uses}

energy (Section \ref{section-energies}), rmsd (Section \ref{section-rmsd})

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

The sum\_energies function should raise a warning if an energy calculation did 
not converge.

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		get\_fitness & list(list(str,$\mathbb{R}$,$\mathbb{R}$,$\mathbb{R}$)), 
		str, str, $\mathbb{Z}$, $\mathbb{R}$, 
		$\mathbb{R}$, $\mathbb{Z}$, $\mathbb{N}$ & $\mathbb{R}$ & None \\
		sum\_energies &  
		list(list(str,$\mathbb{R}$,$\mathbb{R}$,$\mathbb{R}$)), $\mathbb{Z}$, 
		$\mathbb{N}$, str, str & $\mathbb{R}$ 
		& None \\
		sum\_rmsd &  list(list(str,$\mathbb{R}$,$\mathbb{R}$,$\mathbb{R}$)) & 
		$\mathbb{R}$ & None \\
		all\_pairs\_gen & $\mathbb{Z}$ & tuple($\mathbb{Z}, \mathbb{Z}$) & None 
		\\
		calc\_fitness & $\mathbb{Z}$, $\mathbb{R}$, $\mathbb{R}$, $\mathbb{R}$, 
		$\mathbb{R}$ & $\mathbb{R}$ & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item the generator function, all\_pairs\_gen, will need to keep track of 
	the i and j iteration values.
	\item num\_pairs is the number of next() calls needed for the generator. := 
	$\{<y,n> | n = \text{num\_geoms} : \mathbb{N} \land y = n!/(2*(n-2)!) \}$
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

New fitness functions will be added. Each new fitness functions should be 
incrementally labelled and added to the calc\_fitness function. Any new 
fitness functions that are added should account for the possibility of divide 
by zero errors.

\subsubsection{Access Routine Semantics}

\noindent get\_fitness(xyz\_coords, method, basis, fit\_form, coef\_energy, 
coef\_rmsd, charge, multip):
\begin{itemize}
	\item transition: None
	\item output: \textit{out} := $(x: \mathbb{R}| x \geq 0 : x)$
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

\noindent sum\_energies(xyz\_coords, charge, multip, method, basis):
\begin{itemize}
	\item transition: read in the xyz\_coords. 
	\item output: \textit{out} := $+(x: \mathbb{R}|x = \text{energy of 
	xyz\_coords with charge, multiplicity, QCM, BS}: |x|)$
	\item exception: None
\end{itemize}

\noindent sum\_rmsds(xyz\_coords):
\begin{itemize}
	\item transition: read in the xyz\_coords.
	\item output: \textit{out} := $+(x(i,j): \mathbb{R}| \text{RMSD between 
	coords i and j where } i,j \text{ are indices } \forall i,j \in 
	\text{xyz\_coords}: x)$
	\item exception: None
\end{itemize}

\noindent all\_pairs\_gen(num\_geoms):
\begin{itemize}
	\item transition: increment iterators i and j in the generator function.
	\item output: \textit{out} := $\{<i,j>: \mathbb{Z} | 0 \leq i \leq 
	\text{num\_geoms}-1 \land i+1 \leq j \leq \text{num\_geoms}\}$
	\item exception: None
\end{itemize}


\noindent calc\_fitness(fit\_form, sum\_energy, coef\_energy, sum\_rmsd, 
coef\_rmsd):
\begin{itemize}
	\item transition: None
	\item output: when fit\_form = 0, then \textit{out} := \{
	$<<C_E,S_E,C_{\text{RMSD}},S_{\text{RMSD}}>,y> : \mathbb{R} | y = 
	C_E*S_E+C_{\text{RMSD}}*S_{\text{RMSD}} \}$
	\item exception: ValueError fit\_form is not available.
\end{itemize}

\section{MIS of Tournament} \label{section-tournament} 

The tournament module selects t\_size pmems from the ring for comparison. It 
ranks the pmems in order of increasing fitness, as calculated using the fitg 
module (\ref{section-fitg}). Then, the two best pmems are chosen as ``parents", 
and the mutations module (\ref{section-mutations}) is used to generate two new 
``children" based on these parents. The ring module (\ref{section-ring}) then 
decides whether the children are added to the ring or not, and if old pmems are 
deleted to make room for the children.

\subsection{Module}

tournament

\subsection{Uses}

ring (Section \ref{section-ring}),
pmem (Section \ref{section-pmem}),
mutations (Section \ref{section-mutations})

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.5cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		run\_tournament & $\mathbb{N}$, $\mathbb{Z}$, $\mathbb{Z}$, Ring & None 
		& EmptyRingError \\
		select\_pmems & $\mathbb{N}$, Ring & list($\mathbb{Z}$) & None \\
		select\_parents & list, Ring & tuple($\mathbb{Z}$,$\mathbb{Z}$) & None 
		\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item selected\_pmems := $\{x : \mathbb{N} | x \geq 0 \land 
\text{ring.pmems}[x] \neq None\}$
\item parents := $\{x : \mathbb{N} | x \geq 0 \land \text{ring.pmems}[x] \neq 
None\}$
\item parent1 := $[[D_1], [D_2], ..., [D_{n_G}]]$, where each 
$D_i$ is a list of length num\_atoms-3 of integers representing the dihedral 
angles
\item parent2 := $[[D_1], [D_2], ..., [D_{n_G}]]$, where each 
$D_i$ is a list of length num\_atoms-3 of integers representing the dihedral 
angles
\item children := $[[[D_1], [D_2], ..., [D_{n_G}]], [[D_1], [D_2], ..., 
[D_{n_G}]]]$, where each $D_i$ is a list of length num\_atoms-3 of integers 
representing the dihedral 
angles
\end{itemize}


\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None \meow{May have to think on this more.}

\subsubsection{Access Routine Semantics}

\noindent run\_tournament(t\_size, num\_muts, num\_swaps, ring, current\_mev):
\begin{itemize}
	\item transition: new ring members may be added with birthday equal to the 
	current\_mev (increments ring.num\_filled), and old pmems may be replaced 
	with a new pmem.
	\item output: None 
	\item exception: EmptyRingError when t\_size $>$ ring.num\_filled
\end{itemize}

\subsubsection{Local Functions}

\noindent select\_pmems(number, ring):
\begin{itemize}
	\item transition: None
	\item output: selection, which is a list of length \textit{number} of 
	random ring indices containing a pmem; no pmem can appear twice in the 
	selection.
	\item exception: None
\end{itemize}

\noindent select\_parents(selected\_pmems, ring):
\begin{itemize}
	\item transition: None
	\item output: tuple of length 2 representing the ring indices of the pmems 
	with the best fitness values out of the selected\_pmems indices.
	\item exception: None
\end{itemize}

\section{MIS of Crossover \& Mutation} \label{section-mutations}

This module is used to generate new solution instances with which to generate 
new pmems (\ref{section-pmem}) for the ring (\ref{section-ring}). It has two 
local functions, mutate and swap. Mutate takes in a list of lists representing 
dihedral angles for the molecule of interest. Then, a number of these dihedral 
angles are randomly changed. Swap takes in two of such list of lists and swaps 
a number of sublists between the two inputs. This module is called during a 
tournament (\ref{section-tournament}). A wrapper function to call these two 
functions is called generate\_children, which returns the new solution 
instances to the tournament.

\subsection{Module}

mutations

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

These two values restrict the dihedral angles that can be chosen.

MIN\_VALUE : 0\\
\indent MAX\_VALUE : 360

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.5cm} p{4cm} p{3cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		generate\_children & list(list($\mathbb{Z}$)), 
		list(list($\mathbb{Z}$)), $\mathbb{Z}$, $\mathbb{Z}$ & 
		list(list($\mathbb{Z}$)), list(list($\mathbb{Z}$)) & None \\
		mutate & list(list($\mathbb{Z}$)), $\mathbb{Z}$ & 
		list(list($\mathbb{Z}$)) & None \\
		swap & list(list($\mathbb{Z}$)), 
		list(list($\mathbb{Z}$)), $\mathbb{Z}$ & list(list($\mathbb{Z}$)), 
		list(list($\mathbb{Z}$)) & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item number of chosen swaps := $\{ x : \mathbb{Z} | 0 \leq x \leq 
	\text{num\_swaps from ga\_input\_dict}\}$
	\item number of chosen mutations := $\{ x : \mathbb{Z} | 0 \leq x \leq 
	\text{num\_muts from ga\_input\_dict}\}$
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None \meow{Maybe good to reference SRS assumptions about inputs here?}

\subsubsection{Access Routine Semantics}

\noindent generate\_children(parent1, parent2, num\_muts, num\_swaps):
\begin{itemize}
	\item transition: None
	\item output: two list of lists of integers between MIN\_VALUE and 
	MAX\_VALUE representing dihedrals for two new population members. These 
	will be used to create pmem objects.
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

\noindent mutate(dihedrals, num\_muts):
\begin{itemize}
	\item transition: locally update num\_muts with a random number (min 0, max 
	num\_muts).
	\item output: a list of lists of integers between MIN\_VALUE and 
	MAX\_VALUE representing dihedrals for one mutated population member.
	\item exception: None
\end{itemize}

\noindent swap(parent1, parent2, num\_swaps):
\begin{itemize}
	\item transition: locally update num\_swaps with a random number (min 0, 
	max num\_swaps).
	\item output: two list of lists of integers between MIN\_VALUE and 
	MAX\_VALUE representing dihedrals for two swapped population members.
	\item exception: None
\end{itemize}

\section{MIS of Ring} \label{section-ring}

The ring is the main data structure for \progname{}. It determines how the 
potential solutions to the conformer optimization program are organized. The 
constructor for the ring takes 5 arguments: num\_geoms, num\_atoms, num\_slots, 
pmem\_dist, and parser. The ring begins empty and can be filled with pmem 
objects by calling the ring.fill method. There is also the ring.update method, 
which takes 2 arguments: parent\_index and child. This method is called during 
a tournament after the children have been generated. The update occurs as 
follows:
\begin{enumerate}
	\item Select a random slot in the range [parent\_index-pmem\_dist, 
	parent\_index+pmem\_dist+1] from 
	the parent.
	\item Compare the fitness value of the child with the fitness value of the 
	current occupant.
	\item If there is no current occupant, or if the child has fitness $\geq$ 
	the current occupant, put the child in the slot.
	\item Increment the num\_filled attribute of the ring if an empty slot was 
	filled.
\end{enumerate}
The ring also uses the geometry module (Section \ref{section-geometry}) to 
generate a zmatrix as a string based on the pmem index of interest. Calling 
ring.calc\_fitness will determine the fitness for a given pmem index.

\subsection{Module}

ring

\subsection{Uses}

pmem (Section \ref{section-pmem}),
fitg (Section \ref{section-fitg}),
geometry (Section \ref{section-geometry})

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{2cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\_\_init\_\_ & $\mathbb{N}, \mathbb{N}, \mathbb{N}, \mathbb{Z}, 
		\mathbb{Z}, \mathbb{Z}, \mathbb{Z}$ Parser & None & None \\
		set\_fitness & $\mathbb{Z}$ & None & ValueError \\
		update & $\mathbb{Z}$, list(list[$\mathbb{Z}$]) & None & None \\
		fill & $\mathbb{N}, \mathbb{Z}$ & None & RingOverflowError \\
		RingEmptyError  & - & - & - \\
		RingOverflowError & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item ring.num\_geoms from ga\_input\_module
\item ring.num\_atoms from ga\_input\_module
\item ring.pmem\_dist from ga\_input\_module
\item ring.fit\_form from ga\_input\_module
\item ring.coef\_energy from ga\_input\_module
\item ring.coef\_rmsd from ga\_input\_module
\item ring.parser from the geometry module
\item ring.num\_filled from ga\_input\_module; represents the number of pmems 
present in the ring (dynamic)
\item ring.pmems is a list of pmem objects (pmem module) or NoneType objects 
(depends if slot is filled or empty)
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
	\item the ring module will be written in such a way as to support the 
	addition of extinction operators. These extinction operators delete 
	segments and/or pmems with certain attributes from the ring.
	\item a pmem cannot be initialized without a call by the ring to evaluate 
	its fitness. This evaluation will not be a wasted computation.
	\item The ring can be iterated and will not fall over when an index past 
	zero or above the last slot is called (index wrapping).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \_\_init\_\_(num\_geoms, num\_atoms, num\_slots, pmem\_dist, 
fit\_form, coef\_energy, coef\_rmsd, parser):
\begin{itemize}
	\item transition: generate a ring object.
	\item output: None
	\item exception: None
\end{itemize}

\noindent update(parent\_index, child):
\begin{itemize}
	\item transition: generate a pmem with the child (the sets of dihedral 
	angles), and calculate its fitness. Select a slot to place the child within 
	[parent\_index-pmem\_dist, parent\_index+pmem\_dist+1]. If the slot is 
	occupied, the child must have fitness that is no worse than the current 
	occupant. Note: this will require wrapping for the Ring to ensure that an 
	IndexError is not raised. Increment the num\_filled attribute if a slot 
	that was once empty is filled.
	\item output: None
	\item exception: None
\end{itemize}

\noindent fill(num\_pmems, current\_mev):
\begin{itemize}
	\item transition: if there are no pmems in the ring (num\_filled = 0), fill 
	the ring with a contiguous segment of num\_pmems pmems. If there are pmems 
	in the ring, fill empty slots with new pmems until num\_pmem pmems have 
	been added. For each new pmem, calculate its fitness.
	\item output: None
	\item exception: RingOverflowError occurs when there is a request to add a 
	set of pmems to the ring that the number of free slots does not accommodate.
\end{itemize}

\subsubsection{Local Functions}

\noindent set\_fitness(pmem\_index):
\begin{itemize}
	\item transition: updates the pmem.fitness attribute by constructing a 
	zmatrix using the geometry module and calling get\_fitness from the fitg 
	module.
	\item output: None
	\item exception: ValueError occurs if the slot is empty at pmem\_index.
\end{itemize}

\section{MIS of Pmem} \label{section-pmem} %TODO

This module is designed to hold the pmem data structure. A pmem is generated by 
the ring module. The pmem holds the dihedrals list of lists, which is what the 
\progname{} program is optimizing.

\subsection{Module}

pmem

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

These two values restrict the dihedral angles that can be chosen.\\
\indent MIN\_VALUE := 0\\
\indent MAX\_VALUE := 360

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\_\_init\_\_ & $\mathbb{Z}, \mathbb{N}, \mathbb{N}, \mathbb{Z}, 
		list(list(\mathbb{Z}))*$ & None 
		& None \\
		\hline
	\end{tabular}
\end{center}
* the default value is None

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item pmem.ring\_loc := the ring index where the pmem is located.
	\item pmem.dihedrals := $[[D_1], [D_2], ..., [D_{n_G}]]$, where each $D_i$ 
	is a list of length num\_atoms-3 of $\mathbb{Z}$ representing the dihedral 
	angles. If the constructor is called without a given set of dihedrals, then 
	the default will be to randomly fill in those values between MIN\_VALUE and 
	MAX\_VALUE.
	\item pmem.fitness := float representing result of a fitg calculation for 
	the pmem's dihedral angles when combined with the other geometry 
	specifications in ring.parser.
	\item pmem.birthday := $\{x:\mathbb{Z} | num\_mevs > x \geq 0\}$ mating 
	event 
	for which the pmem was generated
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

After a pmem object is generated, its fitness will be calculated.

\subsubsection{Access Routine Semantics}

\noindent \_\_init\_\_(ring\_loc, num\_geoms, num\_atoms, current\_mev, 
dihedrals=None):
\begin{itemize}
	\item transition: generate a new pmem object.
	\item output: None
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of Output} \label{section-output}

The output module is called by the GA Control module (\ref{section-gac}) to 
produce output for the program. There are two main requirements: return the 
best set of conformer geometries with full geometry specifications and 
calculate their respective energies. Although it is not listed in the 
requirements, this module will most likely be upgraded to include some 
statistical measurements of the results.

\subsection{Module}

output

\subsection{Uses}

geometry (Section \ref{section-geometry}),
ring (Section \ref{section-ring}),
pmem (Section \ref{section-pmem})

\subsection{Syntax}

\subsubsection{Exported Constants}

OUTPUT\_FORMAT = ``xyz"

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		run\_output & Ring & $\mathbb{R}, \mathbb{R}$, list($\mathbb{R}$), Ring 
		& None* \\
		\hline
	\end{tabular}
\end{center}

*Need an exception in case the program does not have the permissions 
needed to write to the output directory.

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item total\_fit : the total sum of all fitness values for pmems in the Ring 
(that aren't None), $\mathbb{R} \geq$ 0
\item average\_fit := total\_fit / ring.num\_filled
\item best\_pmem : the ring index for the pmem in the ring with the highest 
fitness value, $\text{ring.num\_slots} \geq \mathbb{Z} \geq$ 0
\item best\_fit : the value of the best fitness as found in the ring,  
$\mathbb{R} \geq$ 0
\end{itemize}


\subsubsection{Environment Variables}

The output files with extension OUTPUT\_FORMAT will be written to the current 
working directory.

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent run\_output(ring):
\begin{itemize}
	\item transition: generate an output files for the best conformer 
	geometries.
	\item output: returns the average fitness value in the ring, the best 
	fitness value in the ring, the energies of the best geometries, and the 
	final ring object.
	\item exception: raise an error if the user doesn't have write permissions 
	in the current working directory.
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of Geometry} \label{section-geometry}

The geometry module is used by the output module (Section 
\ref{section-geometry}), the ring module (Section \ref{section-ring}), and the 
mol\_input module (Section \ref{section-mol_input}). It uses the external 
program Vetee to make a Parser object that is used by the ring. The Parser 
object can represent a few file formats: xyz, com, Gaussian log file (glog). 
The Parser object can also be initialized using a SMILES string, a cid 
(chemical identifier used by pubchem), or a molecule name. This module also 
converts zmatrices to xyz coordinates and vice versa. 

\subsection{Module}

geometry

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		generate\_parser & dict & Parser & NotImplementedError \\
		zmatrix\_to\_xyz & str & list(list(str, $\mathbb{R}, \mathbb{R}, 
		\mathbb{R}$)) & None \\
		generate\_zmatrix & Parser, list(list($\mathbb{Z}$)) & str & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

The Vetee Parser object has the following attributes:
\begin{itemize}
	\item comments: str
	\item charge: charge of the molecule, $\mathbb{Z}$
	\item multip: multiplicity of the molecule, $\mathbb{N}$
	\item calc\_type: str (optimization, single-point, etc.)
	\item coords: list(list(str, $\mathbb{R}, \mathbb{R}, \mathbb{R}$))
	\item gkeywords: dict (keys are Gaussian keywords, values are the arguments 
	for the Gaussian keywords)
	\item fpath: filepath for the input file, str
	\item fname: filename for the input file, str
\end{itemize}

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

None

\subsubsection{Access Routine Semantics}

\noindent generate\_parser(mol\_input\_dict):
\begin{itemize}
	\item transition: None
	\item output: Parser object.
	\item exception: NotImplementedError : struct\_type is not covered by Vetee.
\end{itemize}

\noindent zmatrix\_to\_xyz(zmatrix):
\begin{itemize}
	\item transition: None
	\item output: list(list[atom type (str), x-coord, y-coord, z-coord]) the 
	xyz coordinates and the atomic types.
	\item exception: None
\end{itemize}

\noindent generate\_zmatrix(parser, dihedrals):
\begin{itemize}
	\item transition: None
	\item output: zmatrix (str) that is the combination of the parser.coords 
	and the list(list(dihedral-angles)).
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of Energy} \label{section-energies}

Using the psi4 program, this module is responsible for running energy 
calculations.

\subsection{Module}

energy

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		run\_energy\_calc & str, str, str, bool & $\mathbb{R}$ & None \\
		prep\_psi4\_geom & list(list[str, $\mathbb{R}, \mathbb{R}, 
		\mathbb{R}$]), $\mathbb{Z}, \mathbb{N}$ & str & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item psi4\_str : str representing the geometry specification in the format 
	needed for a psi4 energy calculation.
\end{itemize}


\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

This module can be modified to support multiple programs depending on the 
user's preference for calculation software.

\subsubsection{Access Routine Semantics}

\noindent run\_energy\_calc(geom, method=``scf", basis=``aug-cc-pVTZ",
restricted=False):
\begin{itemize}
	\item transition: None
	\item output: energy ($\mathbb{R}$) of the geometry with the specified QCM 
	and BS (which may be a restricted vs unrestricted calculation depending on 
	the restricted bool).
	\item exception: None
\end{itemize}

\noindent prep\_psi4\_geom(coords, charge, multip):
\begin{itemize}
	\item transition: None
	\item output: str of the psi4 geometry specification needed to perform 
	calculations using a list of cartesian coordinates and atom names, the 
	charge, and the multiplicity of the molecule.
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

None

\section{MIS of RMSD} \label{section-rmsd}

Uses the rmsd repository from github to calculate the root-mean-square 
deviation between all sets of conformer geometries in a pmem. Each pair is sent 
as xyz files to this module independently.

\subsection{Module}

rmsd

\subsection{Uses}

None

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		calc\_rmsd & str, str & $\mathbb{R}$ & None \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item output := standard output from the rmsd module that is converted into 
	a float and returned to the fitg module.
\end{itemize}

\subsubsection{Environment Variables}

Both files are in cartesian coordinates (can also have a pdb file extension).

\begin{itemize}
	\item f1 := file name 1 for the first geometry.
	\item f2 := file name 2 for the second geometry.
\end{itemize}

\subsubsection{Assumptions}

The rmsd repository calculates a rotation matrix such that comparing molecules 
that have only undergone translation and rotation gives an rmsd of 0.

\subsubsection{Access Routine Semantics}

\noindent calc\_rmsd(f1, f2):
\begin{itemize}
	\item transition: open f1 and f2.
	\item output: calculated rmsd.
	\item exception: None
\end{itemize}

\subsubsection{Local Functions}

None


\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

%\section{Appendix} \label{Appendix}

\end{document}